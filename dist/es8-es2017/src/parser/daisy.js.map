{"version":3,"file":"daisy.js","sourceRoot":"","sources":["../../../../src/parser/daisy.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport * as moment from \"moment\";\nimport * as path from \"path\";\nimport * as rnfs from \"react-native-fs\";\n\nimport { Metadata } from \"@models/metadata\";\nimport { Publication } from \"@models/publication\";\nimport { Link } from \"@models/publication-link\";\nimport { isHTTP } from \"@r2-utils-rn/_utils/http/UrlUtils\";\nimport { IZip } from \"@r2-utils-rn/_utils/zip/zip\";\nimport { zipLoadPromise } from \"@r2-utils-rn/_utils/zip/zipFactory\";\n\nimport { zipHasEntry } from \"../_utils/zipHasEntry\";\nimport {\n    addIdentifier, addLanguage, addMediaOverlaySMIL, addOtherMetadata, addTitle,\n    fillPublicationDate, fillSpineAndResource, fillSubject, fillTOC, findContributorInMeta, getNcx,\n    getOpf, lazyLoadMediaOverlays, setPublicationDirection, updateDurations,\n} from \"./epub-daisy-common\";\nimport { Rootfile } from \"./epub/container-rootfile\";\nimport { NCX } from \"./epub/ncx\";\nimport { OPF } from \"./epub/opf\";\nimport { Manifest } from \"./epub/opf-manifest\";\n\nconst debug = debug_(\"r2:shared#parser/daisy\");\n\nexport enum DaisyBookis {\n    LocalExploded = \"LocalExploded\",\n    LocalPacked = \"LocalPacked\",\n    RemoteExploded = \"RemoteExploded\",\n    RemotePacked = \"RemotePacked\",\n}\n\nasync function isLocalExploded(urlOrPath: string): Promise<void> {\n    // TODO replace with Promise.any() polyfill\n    try {\n        await rnfs.stat(path.join(urlOrPath, \"package.opf\"));\n    } catch (_) {\n        try {\n            await rnfs.stat(path.join(urlOrPath, \"Book.opf\"));\n        } catch (_) {\n            try {\n                await rnfs.stat(path.join(urlOrPath, \"speechgen.opf\"));\n            } catch (_) {\n                throw null;\n            }\n        }\n    }\n\n    try {\n        await rnfs.stat(\n            path.join(urlOrPath, \"META-INF\", \"container.xml\"),\n        );\n    } catch (_) {\n        return;\n    }\n\n    throw null;\n}\n\nexport async function isDaisyPublication(urlOrPath: string): Promise<DaisyBookis | undefined> {\n    let p = urlOrPath;\n    const http = isHTTP(urlOrPath);\n    if (http) {\n        const url = new URL(urlOrPath);\n        p = url.pathname;\n        return undefined; // remote DAISY not supported\n    } else if (/\\.daisy[23]?$/.test(path.extname(path.basename(p)).toLowerCase())) {\n        return DaisyBookis.LocalPacked;\n    } else {\n        try {\n            await isLocalExploded(urlOrPath);\n            return DaisyBookis.LocalExploded;\n        } catch (_) {\n            let zip: IZip;\n            try {\n                zip = await zipLoadPromise(urlOrPath);\n            } catch (err) {\n                debug(err);\n                return Promise.reject(err);\n            }\n\n            if (\n                !(await zipHasEntry(zip, \"META-INF/container.xml\", undefined))\n            ) {\n                // if (await zipHasEntry(zip, \"package.opf\", undefined) ||\n                //     await zipHasEntry(zip, \"Book.opf\", undefined) ||\n                //     await zipHasEntry(zip, \"speechgen.opf\", undefined)) {\n                //     return DaisyBookis.LocalPacked;\n                // }\n\n                const entries = await zip.getEntries();\n                const opfZipEntryPath = entries.find((entry) => {\n                    // regexp fails?!\n                    // return /[^/]+\\.opf$/.test(entry);\n                    return entry.endsWith(\".opf\"); // && entry.indexOf(\"/\") < 0 && entry.indexOf(\"\\\\\") < 0;\n                });\n                if (!opfZipEntryPath) {\n                    return undefined;\n                }\n\n                // TODO: check for <dc:Format>ANSI/NISO Z39.86-2005</dc:Format> ?\n                return DaisyBookis.LocalPacked;\n            }\n        }\n    }\n\n    return undefined;\n}\n\n// const isFileValid = (files: string[]) => {\n//     // const keys = Object.keys(files);\n\n//     if (files.some((file) => file.match(/\\.xml$/)) === false) {\n//         return [false, \"No xml file found.\"];\n//     }\n\n//     if (files.some((file) => file.match(/\\/ncc\\.html$/))) {\n//         return [false, \"DAISY 2 format is not supported.\"];\n//     }\n\n//     // if (files.some((file) => file.match(/\\.mp3$/)) === false) {\n//     //   console.log(\"mp3\");\n//     //   return [false];\n//     // }\n//     // if (files.some((file) => file.match(/\\.smil$/)) === false) {\n//     //   console.log(\"smil\");\n//     //   return [false];\n//     // }\n\n//     return [true];\n// };\n\nexport async function DaisyParsePromise(filePath: string): Promise<Publication> {\n\n    // const isDaisy = await isDaisyPublication(filePath);\n\n    let zip: IZip;\n    try {\n        zip = await zipLoadPromise(filePath);\n    } catch (err) {\n        debug(err);\n        return Promise.reject(err);\n    }\n\n    if (!zip.hasEntries()) {\n        return Promise.reject(\"Daisy zip empty\");\n    }\n\n    const publication = new Publication();\n    publication.Context = [\"https://readium.org/webpub-manifest/context.jsonld\"];\n    publication.Metadata = new Metadata();\n    publication.Metadata.RDFType = \"http://schema.org/Book\";\n    publication.Metadata.Modified = moment(Date.now()).toDate();\n\n    publication.AddToInternal(\"filename\", path.basename(filePath));\n\n    publication.AddToInternal(\"type\", \"daisy\");\n    publication.AddToInternal(\"zip\", zip);\n\n    // note: does not work in RemoteExploded\n    const entries = await zip.getEntries();\n\n    // const [valid, message] = isFileValid(entries);\n    // if (!valid) {\n    //     return Promise.reject(message || \"File validation failed.\");\n    // }\n\n    // generic \"text/xml\" content type\n    // manifest/item@media-type\n    const opfZipEntryPath = entries.find((entry) => {\n        // regexp fails?!\n        // return /[^/]+\\.opf$/.test(entry);\n        return entry.endsWith(\".opf\"); // && entry.indexOf(\"/\") < 0 && entry.indexOf(\"\\\\\") < 0;\n    });\n    if (!opfZipEntryPath) {\n        return Promise.reject(\"OPF package XML file cannot be found.\");\n    }\n\n    const rootfilePathDecoded = opfZipEntryPath; // || \"package.opf\";\n    if (!rootfilePathDecoded) {\n        return Promise.reject(\"?!rootfile.PathDecoded\");\n    }\n\n    const opf = await getOpf(zip, rootfilePathDecoded, opfZipEntryPath);\n\n    addLanguage(publication, opf);\n\n    addTitle(publication, undefined, opf);\n\n    addIdentifier(publication, opf);\n\n    addOtherMetadata(publication, undefined, opf);\n\n    setPublicationDirection(publication, opf);\n\n    findContributorInMeta(publication, undefined, opf);\n\n    await fillSpineAndResource(publication, undefined, opf, zip, addLinkData);\n\n    let ncx: NCX | undefined;\n    if (opf.Manifest) {\n        let ncxManItem = opf.Manifest.find((manifestItem) => {\n            return manifestItem.MediaType === \"application/x-dtbncx+xml\";\n        });\n        if (!ncxManItem) {\n            ncxManItem = opf.Manifest.find((manifestItem) => {\n                return manifestItem.MediaType === \"text/xml\" &&\n                    manifestItem.Href && manifestItem.Href.endsWith(\".ncx\");\n            });\n        }\n        if (ncxManItem) {\n            ncx = await getNcx(ncxManItem, opf, zip);\n        }\n    }\n\n    fillTOC(publication, opf, ncx);\n\n    fillSubject(publication, opf);\n\n    fillPublicationDate(publication, undefined, opf);\n\n    return publication;\n}\n\nconst addLinkData = async (\n    publication: Publication, _rootfile: Rootfile | undefined,\n    opf: OPF, zip: IZip, linkItem: Link, item: Manifest) => {\n\n    if (publication.Metadata?.AdditionalJSON) {\n        // dtb:multimediaContent ==> audio,text\n        const isFullTextAudio = publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"audioFullText\";\n\n        // dtb:multimediaContent ==> text\n        const isTextOnly = publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"textNCX\";\n\n        // dtb:multimediaContent ==> audio\n        const isAudioOnly = publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"audioNCX\";\n\n        if (isFullTextAudio || isTextOnly || isAudioOnly) {\n            await addMediaOverlaySMIL(linkItem, item, opf, zip);\n\n            if (linkItem.MediaOverlays && !linkItem.MediaOverlays.initialized) {\n                // mo.initialized true/false is automatically handled\n                await lazyLoadMediaOverlays(publication, linkItem.MediaOverlays);\n\n                if (isFullTextAudio || isAudioOnly) {\n                    updateDurations(linkItem.MediaOverlays.duration, linkItem);\n                }\n            }\n        }\n    }\n};\n"]}